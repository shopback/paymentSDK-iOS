{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mobile paymentSDK Integration Guide for iOS \u00b6 Introduction \u00b6 paymentSDK was created to provide card payments to mobile applications and make PCI SAQ-A compliance easy. It decreases merchant integration effort and offers nice UX. Beside Card payments alternative payment methods were implemented to reduce integration costs on merchant side. Merchants shall use paymentSDK only when it is necessary and useful. It means when consumer interaction is needed to finish transaction because mobile devices are unreliable (battery, network, ...). You can integrate gateway REST API to trigger recurring payments to avoid unreliable mobile devices. Your solutions shall not solely rely on paymentSDK responses. Wirecard Payment Gateway offers more reliable way of payment result delivery. You can set Instant Payment Notifications in your merchant account configuration or you can override IPN account configuration in payment request Mobile paymentSDK is divided into a core framework and optional frameworks, one for each payment method. With this modular approach, you can pick and choose what you need: a few payment methods (or even just one) or the full selection. Below, we will briefly go through the basic requirements/dependencies, but also code examples for client initialization and processing the payment response on your end. System Requirements \u00b6 Operating system \u00b6 iOS versions: 9.x , 10.x , 11.x , 12.x Device Requirements \u00b6 iPhone iPad iPhone 4s ; iOS 9.x iPad 2 iPhone 5 iPad (3\u02b3\u1d48 generation) iPhone 5c iPad (4\u1d57\u02b0 generation) iPhone 5s iPad Air iPhone 6 iPad Air 2 iPhone 6 Plus iPad (5\u1d57\u02b0 generation) iPhone 6S iPad (6\u1d57\u02b0 generation) iPhone 6S Plus iPad mini iPhone SE iPad mini 2 iPhone 7 iPad mini 3 iPhone 7 Plus iPad mini 4 iPhone 8 iPad Pro iPhone 8 Plus iPhone X iPhone X\ud83c\udd42 iPhone X\ud83c\udd42 Max iPhone X\ud83c\udd41 Integration Details \u00b6 Available gateways \u00b6 Mobile paymentSDK can connect to these gateways: Gateway Hostname Germany - production api.wirecard.com Germany - test api-test.wirecard.com Singapore - production api.wirecard.com.sg Singapore - test test.wirecard.com.sg UK & Ireland - production engine.elastic-payments.com UK & Ireland - test sandbox-engine.thesolution.com Central and East Europe - production api-wdcee.wirecard.com Central and East Europe - test api-wdcee-test.wirecard.com Integration to your Xcode project \u00b6 paymentSDK can be easily integrated to your project by 2 major dependency managers for Xcode projects: Cocoapods \u00b6 CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 50 thousand libraries and is used in over 3 million apps. Wirecard paymentSDK is one of them. Available Cocoapods subspecs: 1 2 3 4 5 6 7 8 9 10 11 12 pod 'paymentSDK' , '~> None' # or you can use only needed subspecs to decrease your app's size and to avoid granting redundant permissions. pod 'paymentSDK/ApplePay' , '~> None' pod 'paymentSDK/Card' , '~> None' pod 'paymentSDK/CardScanner' , '~> None' pod 'paymentSDK/PayPal' , '~> None' pod 'paymentSDK/SEPA' , '~> None' pod 'paymentSDK/IBANScanner' , '~> None' pod 'paymetnSDK/ZAPP' , '~> None' pod 'paymetnSDK/Scanner' , '~> None' pod 'paymetnSDK/PhotoGallery' , '~> None' Carthage \u00b6 Carthage is simple, decentralized dependency manager for Cocoa. You do not rely on 3rd party repositories at build/release time. You download and integrate all dependencies at integration time. Create Cartfile with following components 1 2 3 4 5 6 7 8 9 10 github \" AFNetworking/AFNetworking \" github \" CocoaLumberjack/CocoaLumberjack \" github \" wirecard/libextobjc \" github \" granoff/Lockbox \" github \" Mantle/Mantle \" github \" jdg/MBProgressHUD \" github \" michaeltyson/TPKeyboardAvoiding \" github \" google/gtm-session-fetcher \" github \" google/google-toolbox-for-mac \" binary https : // dl . google . com / dl / firebase / ios / carthage / FirebaseMLVisionTextModelBinary . json Run carthage update Copy the frameworks in $(PROJECT_DIR)/Carthage/Build/iOS into the top level of your Xcode project and make sure they're added to the right build target(s). plist files of Firebase frameworks located in $(PROJECT_DIR)/Carthage/Build/iOS doesn\u2019t have unique names, CFBundleName should be changed according framework name Add following flags to Other Linker Flags in Build Settings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 - ObjC - l \"c++\" - l \"sqlite3\" - l \"xml2\" -| \"z\" - framework \"AVFoundation\" - framework \"Accelerate\" - framework \"CoreGraphics\" - framework \"CoreVideo\" - framework \"CoreImage\" - framework \"CoreMedia\" - framework \"Foundation\" - framework \"MobileCoreServices\" - framework \"QuartzCore\" - framework \"WDeCom\" and append optional SDK frameworks used by your integration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 - framework \"WDeApplePay\" - framework \"WDeComCard\" - framework \"WDeComCardScanner\" - framework \"WDeComCoreCard\" - framework \"WDeComIBANScanner\" - framework \"WDeComPayPal\" - framework \"WDeComSEPA\" - framework \"WDeComZAPP\" Add following to Framework search paths in Build Settings 1 2 $( inherited ) $( PROJECT_DIR ) /Carthage/Build/iOS You're including a FirebaseMLVisionTextModel component that has resources. You need to copy its bundles into the Xcode project and make sure they're added to the Copy Bundle Resources Build Phase : 1 $( PROJECT_DIR ) /Carthage/Build/iOS/TextDetector.framework/GoogleMVTextDetectorResources.bundle Code Examples \u00b6 Client initialization \u00b6 When creating a payment object, don't forget to initialize the client first: Swift 1 2 3 4 5 6 7 do { let parameters = WDECClientParameters () parameters . timeoutInterval = 30 self . client = try WDECClient ( hostname : \"api-test.wirecard.com\" , parameters : parameters ) } catch let error { } Objective-C 1 2 3 4 5 6 7 8 9 NSError * error = nil ; WDECClientParameters * parameters = [ WDECClientParameters new ]; parameters . timeoutInterval = 30 ; self . client = [[ WDECClient alloc ] initWithHostname : @\"api-test.wirecard.com\" parameters : parameters error : & error ]; // or with default network requests timeout 60 seconds self . client = [[ WDECClient alloc ] initWithHostname : @\"api-test.wirecard.com\" error : & error ]; For a successful initialization, WDECClient requires Wirecard payment gateway hostname and optional parameters . Check payment \u00b6 This is example code for requesting transaction result (as possible part of recovery scenario), after the payment goes through: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 let payment = WDECPayment () payment . merchantAccountID = \"example-merchant-account-id\" payment . requestID = \"example-request-id\" payment . signature = \"server side computed signature signed by secret key\" // data can be reused from failed transaction self . client ?. check ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 WDECPayment * payment = [ WDECPayment new ]; payment . merchantAccountID = @\"example-merchant-account-id\" ; payment . requestID = @\"example-request-id\" ; payment . signature = @\"server side computed signature signed by secret key\" ; // data can be reused from failed transaction @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); if ( error ) { // in error case - error object is always provided IPLogError ( @\"error: %@\" , error ); } // response object is provided from gateway. // in case of failed transaction error is created as well [ self handleResponse : response error : error ]; }; [ self . client checkPayment : payment withCompletion : completionBlock ]; Instant Payment Notification \u00b6 Instant Payment Notification can be configured for merchant account id and all transactions. However merchant account configuration can be overriden in particular request if it is needed. This is example code for overriding Instant Payment Notification URL in particular request: Swift 1 2 3 4 5 let notification = WDECNotification () notification . url = URL ( string : \"https://example.com/notification\" ) ! let payment = WDECPayment () payment . notifications = [ notification ] Objective-C 1 2 3 4 5 WDECNotification * notification = [ WDECNotification new ]; notification . URL = [ NSURL URLWithString : @\"https://example.com/notification\" ]; WDECPayment * payment = [ WDECCardPayment new ]; payment . notifications = @[ notification ] ; API Reference \u00b6 WDECClient WDECPayment WDECPaymentResponse WDECErrorCode -s provided in [ NSError code ]","title":"Start Here"},{"location":"#mobile-paymentsdk-integration-guide-for-ios","text":"","title":"Mobile paymentSDK Integration Guide for iOS"},{"location":"#introduction","text":"paymentSDK was created to provide card payments to mobile applications and make PCI SAQ-A compliance easy. It decreases merchant integration effort and offers nice UX. Beside Card payments alternative payment methods were implemented to reduce integration costs on merchant side. Merchants shall use paymentSDK only when it is necessary and useful. It means when consumer interaction is needed to finish transaction because mobile devices are unreliable (battery, network, ...). You can integrate gateway REST API to trigger recurring payments to avoid unreliable mobile devices. Your solutions shall not solely rely on paymentSDK responses. Wirecard Payment Gateway offers more reliable way of payment result delivery. You can set Instant Payment Notifications in your merchant account configuration or you can override IPN account configuration in payment request Mobile paymentSDK is divided into a core framework and optional frameworks, one for each payment method. With this modular approach, you can pick and choose what you need: a few payment methods (or even just one) or the full selection. Below, we will briefly go through the basic requirements/dependencies, but also code examples for client initialization and processing the payment response on your end.","title":"Introduction"},{"location":"#system-requirements","text":"","title":"System Requirements"},{"location":"#operating-system","text":"iOS versions: 9.x , 10.x , 11.x , 12.x","title":"Operating system"},{"location":"#device-requirements","text":"iPhone iPad iPhone 4s ; iOS 9.x iPad 2 iPhone 5 iPad (3\u02b3\u1d48 generation) iPhone 5c iPad (4\u1d57\u02b0 generation) iPhone 5s iPad Air iPhone 6 iPad Air 2 iPhone 6 Plus iPad (5\u1d57\u02b0 generation) iPhone 6S iPad (6\u1d57\u02b0 generation) iPhone 6S Plus iPad mini iPhone SE iPad mini 2 iPhone 7 iPad mini 3 iPhone 7 Plus iPad mini 4 iPhone 8 iPad Pro iPhone 8 Plus iPhone X iPhone X\ud83c\udd42 iPhone X\ud83c\udd42 Max iPhone X\ud83c\udd41","title":"Device Requirements"},{"location":"#integration-details","text":"","title":"Integration Details"},{"location":"#available-gateways","text":"Mobile paymentSDK can connect to these gateways: Gateway Hostname Germany - production api.wirecard.com Germany - test api-test.wirecard.com Singapore - production api.wirecard.com.sg Singapore - test test.wirecard.com.sg UK & Ireland - production engine.elastic-payments.com UK & Ireland - test sandbox-engine.thesolution.com Central and East Europe - production api-wdcee.wirecard.com Central and East Europe - test api-wdcee-test.wirecard.com","title":"Available gateways"},{"location":"#integration-to-your-xcode-project","text":"paymentSDK can be easily integrated to your project by 2 major dependency managers for Xcode projects:","title":"Integration to your Xcode project"},{"location":"#cocoapods","text":"CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 50 thousand libraries and is used in over 3 million apps. Wirecard paymentSDK is one of them. Available Cocoapods subspecs: 1 2 3 4 5 6 7 8 9 10 11 12 pod 'paymentSDK' , '~> None' # or you can use only needed subspecs to decrease your app's size and to avoid granting redundant permissions. pod 'paymentSDK/ApplePay' , '~> None' pod 'paymentSDK/Card' , '~> None' pod 'paymentSDK/CardScanner' , '~> None' pod 'paymentSDK/PayPal' , '~> None' pod 'paymentSDK/SEPA' , '~> None' pod 'paymentSDK/IBANScanner' , '~> None' pod 'paymetnSDK/ZAPP' , '~> None' pod 'paymetnSDK/Scanner' , '~> None' pod 'paymetnSDK/PhotoGallery' , '~> None'","title":"Cocoapods"},{"location":"#carthage","text":"Carthage is simple, decentralized dependency manager for Cocoa. You do not rely on 3rd party repositories at build/release time. You download and integrate all dependencies at integration time. Create Cartfile with following components 1 2 3 4 5 6 7 8 9 10 github \" AFNetworking/AFNetworking \" github \" CocoaLumberjack/CocoaLumberjack \" github \" wirecard/libextobjc \" github \" granoff/Lockbox \" github \" Mantle/Mantle \" github \" jdg/MBProgressHUD \" github \" michaeltyson/TPKeyboardAvoiding \" github \" google/gtm-session-fetcher \" github \" google/google-toolbox-for-mac \" binary https : // dl . google . com / dl / firebase / ios / carthage / FirebaseMLVisionTextModelBinary . json Run carthage update Copy the frameworks in $(PROJECT_DIR)/Carthage/Build/iOS into the top level of your Xcode project and make sure they're added to the right build target(s). plist files of Firebase frameworks located in $(PROJECT_DIR)/Carthage/Build/iOS doesn\u2019t have unique names, CFBundleName should be changed according framework name Add following flags to Other Linker Flags in Build Settings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 - ObjC - l \"c++\" - l \"sqlite3\" - l \"xml2\" -| \"z\" - framework \"AVFoundation\" - framework \"Accelerate\" - framework \"CoreGraphics\" - framework \"CoreVideo\" - framework \"CoreImage\" - framework \"CoreMedia\" - framework \"Foundation\" - framework \"MobileCoreServices\" - framework \"QuartzCore\" - framework \"WDeCom\" and append optional SDK frameworks used by your integration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 - framework \"WDeApplePay\" - framework \"WDeComCard\" - framework \"WDeComCardScanner\" - framework \"WDeComCoreCard\" - framework \"WDeComIBANScanner\" - framework \"WDeComPayPal\" - framework \"WDeComSEPA\" - framework \"WDeComZAPP\" Add following to Framework search paths in Build Settings 1 2 $( inherited ) $( PROJECT_DIR ) /Carthage/Build/iOS You're including a FirebaseMLVisionTextModel component that has resources. You need to copy its bundles into the Xcode project and make sure they're added to the Copy Bundle Resources Build Phase : 1 $( PROJECT_DIR ) /Carthage/Build/iOS/TextDetector.framework/GoogleMVTextDetectorResources.bundle","title":"Carthage"},{"location":"#code-examples","text":"","title":"Code Examples"},{"location":"#client-initialization","text":"When creating a payment object, don't forget to initialize the client first: Swift 1 2 3 4 5 6 7 do { let parameters = WDECClientParameters () parameters . timeoutInterval = 30 self . client = try WDECClient ( hostname : \"api-test.wirecard.com\" , parameters : parameters ) } catch let error { } Objective-C 1 2 3 4 5 6 7 8 9 NSError * error = nil ; WDECClientParameters * parameters = [ WDECClientParameters new ]; parameters . timeoutInterval = 30 ; self . client = [[ WDECClient alloc ] initWithHostname : @\"api-test.wirecard.com\" parameters : parameters error : & error ]; // or with default network requests timeout 60 seconds self . client = [[ WDECClient alloc ] initWithHostname : @\"api-test.wirecard.com\" error : & error ]; For a successful initialization, WDECClient requires Wirecard payment gateway hostname and optional parameters .","title":"Client initialization"},{"location":"#check-payment","text":"This is example code for requesting transaction result (as possible part of recovery scenario), after the payment goes through: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 let payment = WDECPayment () payment . merchantAccountID = \"example-merchant-account-id\" payment . requestID = \"example-request-id\" payment . signature = \"server side computed signature signed by secret key\" // data can be reused from failed transaction self . client ?. check ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 WDECPayment * payment = [ WDECPayment new ]; payment . merchantAccountID = @\"example-merchant-account-id\" ; payment . requestID = @\"example-request-id\" ; payment . signature = @\"server side computed signature signed by secret key\" ; // data can be reused from failed transaction @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); if ( error ) { // in error case - error object is always provided IPLogError ( @\"error: %@\" , error ); } // response object is provided from gateway. // in case of failed transaction error is created as well [ self handleResponse : response error : error ]; }; [ self . client checkPayment : payment withCompletion : completionBlock ];","title":"Check payment"},{"location":"#instant-payment-notification","text":"Instant Payment Notification can be configured for merchant account id and all transactions. However merchant account configuration can be overriden in particular request if it is needed. This is example code for overriding Instant Payment Notification URL in particular request: Swift 1 2 3 4 5 let notification = WDECNotification () notification . url = URL ( string : \"https://example.com/notification\" ) ! let payment = WDECPayment () payment . notifications = [ notification ] Objective-C 1 2 3 4 5 WDECNotification * notification = [ WDECNotification new ]; notification . URL = [ NSURL URLWithString : @\"https://example.com/notification\" ]; WDECPayment * payment = [ WDECCardPayment new ]; payment . notifications = @[ notification ] ;","title":"Instant Payment Notification"},{"location":"#api-reference","text":"WDECClient WDECPayment WDECPaymentResponse WDECErrorCode -s provided in [ NSError code ]","title":"API Reference"},{"location":"apple-pay/","text":"Apple Pay \u00b6 paymentSDK supports credit and debit cards from the three major payment organisations, namely American Express, MasterCard and Visa. Apple Pay can be set up easily, with the consumer simply adding their credit or debit card linked to the Wallet application to their account. Apple Pay generates a dynamic security code to guarantee the security of every transaction. Supported Transaction Types \u00b6 WDECTransactionTypeAuthorization - Reserves funds from the [Account Holder]'s account. 7 days left to conduct a [Capture] on this transaction. WDECTransactionTypePurchase - Takes funds from the [Card Holder]'s account. A one-step process to conduct two Transaction Types: [Authorization] and [Capture]. Basic Setup \u00b6 Cocoapods \u00b6 Add to your app's Podfile subspecs: 1 pod 'paymentSDK/ApplePay' , '~> None' Simple flow (SDK managed) \u00b6 Then you can go ahead and create the payment object: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. let payment = WDECApplePayManagedPayment () payment . appleMerchantID = appleMerchantID payment . appleMerchantCountry = . GB payment . amount = amount payment . currency = currency payment . transactionType = transactionType payment . signature = signature // 3. Trigger the payment and handle response in payment completion block. self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. WDECApplePayManagedPayment * payment = [ WDECApplePayManagedPayment new ]; payment . appleMerchantID = appleMerchantID ; payment . appleMerchantCountry = WDECCountryGB ; payment . amount = amount ; payment . currency = currency ; payment . transactionType = transactionType ; payment . signature = signature ; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ]; Merchant managed flow \u00b6 Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 let request = PKPaymentRequest () request . currencyCode = currency request . countryCode = \"GB\" request . merchantIdentifier = appleMerchantID request . merchantCapabilities = [ PKMerchantCapability . capability3DS , PKMerchantCapability . capabilityCredit , PKMerchantCapability . capabilityDebit ] request . supportedNetworks = [ PKPaymentNetwork . masterCard , PKPaymentNetwork . visa ] request . requiredShippingAddressFields = . all request . requiredBillingAddressFields = . all let shippingMethod1 = PKShippingMethod ( label : \"Delivery in Pub\" , amount : NSDecimalNumber . zero ) shippingMethod1 . identifier = ApplePayConstants . IP_SHIPPING_METHOD_1_ID shippingMethod1 . detail = \"the best option\" let shippingMethod2 = PKShippingMethod ( label : \"Delivery to Desert\" , amount : NSDecimalNumber ( string : \"0.01\" )) shippingMethod2 . identifier = ApplePayConstants . SHIPPING_METHOD_2_ID shippingMethod2 . detail = \"not recommended\" request . shippingMethods = [ shippingMethod1 , shippingMethod2 ] let item1 = PKPaymentSummaryItem ( label : \"Beer\" , amount : amount ) let item2 = PKPaymentSummaryItem ( label : \"Another beer\" , amount : amount ) self . baseItems = [ item1 , item2 ] if let paymentSummaryItems = self . createSummaryItemsWithShippingMethod ( shippingMethod : shippingMethod1 ) { request . paymentSummaryItems = paymentSummaryItems } if let paymentAuthorizationVC = PKPaymentAuthorizationViewController ( paymentRequest : request ) { paymentAuthorizationVC . delegate = self self . present ( paymentAuthorizationVC , animated : true , completion : nil ) } else { error = self . errorWithCode ( code : 6 , desctiption : \"Invalid in-app payment request.\" ) self . handleResponse ( response : nil , error : & error ) } Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 PKPaymentRequest * request = [[ PKPaymentRequest alloc ] init ]; request . currencyCode = currency ; request . countryCode = @\"GB\" ; request . merchantIdentifier = appleMerchantID ; request . merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityCredit | PKMerchantCapabilityDebit ; request . supportedNetworks = @[ PKPaymentNetworkMasterCard , PKPaymentNetworkVisa ] ; request . requiredShippingAddressFields = PKAddressFieldAll ; request . requiredBillingAddressFields = PKAddressFieldAll ; PKShippingMethod * shippingMethod1 = [ PKShippingMethod summaryItemWithLabel : @\"Delivery in Pub\" amount :[ NSDecimalNumber zero ]]; shippingMethod1 . identifier = IP_SHIPPING_METHOD_1_ID ; shippingMethod1 . detail = @\"the best option\" ; PKShippingMethod * shippingMethod2 = [ PKShippingMethod summaryItemWithLabel : @\"Delivery to Desert\" amount :[ NSDecimalNumber decimalNumberWithString : @\"0.01\" ]]; shippingMethod2 . identifier = IP_SHIPPING_METHOD_2_ID ; shippingMethod2 . detail = @\"not recommended\" ; request . shippingMethods = @[ shippingMethod1 , shippingMethod2 ] ; PKPaymentSummaryItem * item1 = [ PKPaymentSummaryItem summaryItemWithLabel : @\"Beer\" amount : amount ]; PKPaymentSummaryItem * item2 = [ PKPaymentSummaryItem summaryItemWithLabel : @\"Friend's beer\" amount : amount ]; self . baseItems = @[ item1 , item2 ] ; request . paymentSummaryItems = [ self createSummaryItemsWithShippingMethod : shippingMethod1 ]; PKPaymentAuthorizationViewController * paymentAuthorizationVC = [[ PKPaymentAuthorizationViewController alloc ] initWithPaymentRequest : request ]; if ( ! paymentAuthorizationVC ) { error = [ self errorWithCode : 6 andDescription : @\"Invalid in-app payment request.\" ]; [ self handleResponse : nil error : error ]; return ; } paymentAuthorizationVC . delegate = self ; [ self presentViewController : paymentAuthorizationVC animated : YES completion : nil ]; When user did authorize Apple pay payment, create WDECApplePayPayment payment object and make payment. Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func paymentAuthorizationViewController ( _ controller : PKPaymentAuthorizationViewController , didAuthorizePayment payment : PKPayment , completion : @ escaping ( PKPaymentAuthorizationStatus ) -> Void ) { let payment = WDECApplePayPayment () payment . payment = payment payment . summaryItems = self . summaryItems payment . currency = currency payment . transactionType = . purchase self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) } Objective-C 1 2 3 4 5 6 7 8 9 10 11 - ( void ) paymentAuthorizationViewController: ( PKPaymentAuthorizationViewController * ) controller didAuthorizePayment: ( PKPayment * ) PKPayment completion: ( void ( ^ )( PKPaymentAuthorizationStatus status )) completion { WDECApplePayPayment * payment = [ WDECApplePayPayment new ]; payment . payment = PKPayment ; payment . summaryItems = self . sumaryItems ; payment . currency = currency ; payment . transactionType = WDECTransactionTypePurchase ; [ self . client makePayment : payment withCompletion : completionBlock ]; } Customization \u00b6 You can modify the basic behaviour by setting following values: requiredBillingAddress - whether shipping address is required requiredShippingAddress - whether billing address is required supportedCardBrands - limits set of supported card brands This configuration is available only in WDECApplePayManagedPayment . Please refer to API documentation for more options.","title":"Apple Pay"},{"location":"apple-pay/#apple-pay","text":"paymentSDK supports credit and debit cards from the three major payment organisations, namely American Express, MasterCard and Visa. Apple Pay can be set up easily, with the consumer simply adding their credit or debit card linked to the Wallet application to their account. Apple Pay generates a dynamic security code to guarantee the security of every transaction.","title":"Apple Pay"},{"location":"apple-pay/#supported-transaction-types","text":"WDECTransactionTypeAuthorization - Reserves funds from the [Account Holder]'s account. 7 days left to conduct a [Capture] on this transaction. WDECTransactionTypePurchase - Takes funds from the [Card Holder]'s account. A one-step process to conduct two Transaction Types: [Authorization] and [Capture].","title":"Supported Transaction Types"},{"location":"apple-pay/#basic-setup","text":"","title":"Basic Setup"},{"location":"apple-pay/#cocoapods","text":"Add to your app's Podfile subspecs: 1 pod 'paymentSDK/ApplePay' , '~> None'","title":"Cocoapods"},{"location":"apple-pay/#simple-flow-sdk-managed","text":"Then you can go ahead and create the payment object: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. let payment = WDECApplePayManagedPayment () payment . appleMerchantID = appleMerchantID payment . appleMerchantCountry = . GB payment . amount = amount payment . currency = currency payment . transactionType = transactionType payment . signature = signature // 3. Trigger the payment and handle response in payment completion block. self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. WDECApplePayManagedPayment * payment = [ WDECApplePayManagedPayment new ]; payment . appleMerchantID = appleMerchantID ; payment . appleMerchantCountry = WDECCountryGB ; payment . amount = amount ; payment . currency = currency ; payment . transactionType = transactionType ; payment . signature = signature ; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ];","title":"Simple flow (SDK managed)"},{"location":"apple-pay/#merchant-managed-flow","text":"Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 let request = PKPaymentRequest () request . currencyCode = currency request . countryCode = \"GB\" request . merchantIdentifier = appleMerchantID request . merchantCapabilities = [ PKMerchantCapability . capability3DS , PKMerchantCapability . capabilityCredit , PKMerchantCapability . capabilityDebit ] request . supportedNetworks = [ PKPaymentNetwork . masterCard , PKPaymentNetwork . visa ] request . requiredShippingAddressFields = . all request . requiredBillingAddressFields = . all let shippingMethod1 = PKShippingMethod ( label : \"Delivery in Pub\" , amount : NSDecimalNumber . zero ) shippingMethod1 . identifier = ApplePayConstants . IP_SHIPPING_METHOD_1_ID shippingMethod1 . detail = \"the best option\" let shippingMethod2 = PKShippingMethod ( label : \"Delivery to Desert\" , amount : NSDecimalNumber ( string : \"0.01\" )) shippingMethod2 . identifier = ApplePayConstants . SHIPPING_METHOD_2_ID shippingMethod2 . detail = \"not recommended\" request . shippingMethods = [ shippingMethod1 , shippingMethod2 ] let item1 = PKPaymentSummaryItem ( label : \"Beer\" , amount : amount ) let item2 = PKPaymentSummaryItem ( label : \"Another beer\" , amount : amount ) self . baseItems = [ item1 , item2 ] if let paymentSummaryItems = self . createSummaryItemsWithShippingMethod ( shippingMethod : shippingMethod1 ) { request . paymentSummaryItems = paymentSummaryItems } if let paymentAuthorizationVC = PKPaymentAuthorizationViewController ( paymentRequest : request ) { paymentAuthorizationVC . delegate = self self . present ( paymentAuthorizationVC , animated : true , completion : nil ) } else { error = self . errorWithCode ( code : 6 , desctiption : \"Invalid in-app payment request.\" ) self . handleResponse ( response : nil , error : & error ) } Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 PKPaymentRequest * request = [[ PKPaymentRequest alloc ] init ]; request . currencyCode = currency ; request . countryCode = @\"GB\" ; request . merchantIdentifier = appleMerchantID ; request . merchantCapabilities = PKMerchantCapability3DS | PKMerchantCapabilityCredit | PKMerchantCapabilityDebit ; request . supportedNetworks = @[ PKPaymentNetworkMasterCard , PKPaymentNetworkVisa ] ; request . requiredShippingAddressFields = PKAddressFieldAll ; request . requiredBillingAddressFields = PKAddressFieldAll ; PKShippingMethod * shippingMethod1 = [ PKShippingMethod summaryItemWithLabel : @\"Delivery in Pub\" amount :[ NSDecimalNumber zero ]]; shippingMethod1 . identifier = IP_SHIPPING_METHOD_1_ID ; shippingMethod1 . detail = @\"the best option\" ; PKShippingMethod * shippingMethod2 = [ PKShippingMethod summaryItemWithLabel : @\"Delivery to Desert\" amount :[ NSDecimalNumber decimalNumberWithString : @\"0.01\" ]]; shippingMethod2 . identifier = IP_SHIPPING_METHOD_2_ID ; shippingMethod2 . detail = @\"not recommended\" ; request . shippingMethods = @[ shippingMethod1 , shippingMethod2 ] ; PKPaymentSummaryItem * item1 = [ PKPaymentSummaryItem summaryItemWithLabel : @\"Beer\" amount : amount ]; PKPaymentSummaryItem * item2 = [ PKPaymentSummaryItem summaryItemWithLabel : @\"Friend's beer\" amount : amount ]; self . baseItems = @[ item1 , item2 ] ; request . paymentSummaryItems = [ self createSummaryItemsWithShippingMethod : shippingMethod1 ]; PKPaymentAuthorizationViewController * paymentAuthorizationVC = [[ PKPaymentAuthorizationViewController alloc ] initWithPaymentRequest : request ]; if ( ! paymentAuthorizationVC ) { error = [ self errorWithCode : 6 andDescription : @\"Invalid in-app payment request.\" ]; [ self handleResponse : nil error : error ]; return ; } paymentAuthorizationVC . delegate = self ; [ self presentViewController : paymentAuthorizationVC animated : YES completion : nil ]; When user did authorize Apple pay payment, create WDECApplePayPayment payment object and make payment. Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func paymentAuthorizationViewController ( _ controller : PKPaymentAuthorizationViewController , didAuthorizePayment payment : PKPayment , completion : @ escaping ( PKPaymentAuthorizationStatus ) -> Void ) { let payment = WDECApplePayPayment () payment . payment = payment payment . summaryItems = self . summaryItems payment . currency = currency payment . transactionType = . purchase self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) } Objective-C 1 2 3 4 5 6 7 8 9 10 11 - ( void ) paymentAuthorizationViewController: ( PKPaymentAuthorizationViewController * ) controller didAuthorizePayment: ( PKPayment * ) PKPayment completion: ( void ( ^ )( PKPaymentAuthorizationStatus status )) completion { WDECApplePayPayment * payment = [ WDECApplePayPayment new ]; payment . payment = PKPayment ; payment . summaryItems = self . sumaryItems ; payment . currency = currency ; payment . transactionType = WDECTransactionTypePurchase ; [ self . client makePayment : payment withCompletion : completionBlock ]; }","title":"Merchant managed flow"},{"location":"apple-pay/#customization","text":"You can modify the basic behaviour by setting following values: requiredBillingAddress - whether shipping address is required requiredShippingAddress - whether billing address is required supportedCardBrands - limits set of supported card brands This configuration is available only in WDECApplePayManagedPayment . Please refer to API documentation for more options.","title":"Customization"},{"location":"card-payments/","text":"Card Payments \u00b6 Supported Transaction Types \u00b6 This payment method supports the following transaction types : WDECTransactionTypeAuthorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. WDECTransactionTypeAuthorizationOnly - verifies the validity of account holder's card, but does not leave an authorized amount. WDECTransactionTypePurchase - charges the account holder's card and immediately transfers the reserved amount. WDECTransactionTypeReferencedAuthorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. References a previous WDECTransactionTypeAuthorization transaction. WDECTransactionTypeReferencedPurchase - charges the account holder's card and immediately transfers the reserved amount. References a previous WDECTransactionTypePurchase transaction. WDECTransactionTypeTokenize - provides a unique token which represents the tokenized card data. This token then can be used in future transactions. Basic Setup \u00b6 Cocoapods \u00b6 Add to your app's Podfile subspecs: 1 2 3 pod 'paymentSDK/Card' , '~> None' # just by adding CardScanner subspec consumers get option to scan card pod 'paymentSDK/CardScanner' , '~> None' Camera Permission \u00b6 To make sure Card Scanner has permission before using camera to scan card, follow the steps in Apple documentation . You need to include NSCameraUsageDescription in your app's Info.plist file. Basic Card Payment \u00b6 The most simple card payment flow require This is a code example for a basic card payment: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. let payment = WDECCardPayment () payment . merchantAccountID = merchantAccountID // provided by merchant support payment . requestID = requestID // generated on server; unique for merchantAccountID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . purchase payment . signature = signature // 3. Trigger the payment and handle response in payment completion block. self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to your server for validation or directly provided by your server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored and used for computation in mobile application WDECCardPayment * payment = [ WDECCardPayment new ]; payment . merchantAccountID = merchantAccountID ; // provided by merchant support payment . requestID = requestID ; // generated on your server; unique for merchantAccountID payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypePurchase ; payment . signature = signature ; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ]; Note: You can set optional properties after the payment object is created. Check the API documentation: WDECCardPayment and WDECPayment for more details. Card Token Payment \u00b6 Token payment in paymentSDK is useful only when you need user interaction. Usually token payment is used in together with EMV\u00ae 3-D Secure. This is a code example for a card payment which uses a card token (obtained from a previous transaction): Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } //first payment let payment = WDECCardPayment () payment . merchantAccountID = merchantAccountID payment . requestID = requestID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . purchase payment . signature = signature self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) func handleReponse ( _ response : WDECPaymentResponse ?) { if let response = response { let cardResponse = response as ? WDECCardPaymentResponse if let cardToken = cardResponse ?. cardToken { //second payment let payment = WDECCardPayment () payment . merchantAccountID = merchantAccountID payment . requestID = requestID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . purchase payment . token = cardToken payment . signature = signature } } } Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } //first payment WDECCardPayment * payment = [ WDECCardPayment new ]; payment . merchantAccountID = merchantAccountID ; payment . requestID = requestID ; payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypePurchase ; payment . signature = signature ; @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } [ self . client makePayment : payment withCompletion : completionBlock ]; Card Field \u00b6 Card Field is user interface compontent for collecting sensitive card data (card number, expiration date and security code) which can be added to your UIView as part of your screen/design. Here's example code for a card payment using card field: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @IBOutlet weak var cardField : WDECCardField ! do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } let payment = WDECCardPayment () payment . merchantAccountID = merchantAccountID payment . requestID = requestID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . purchase payment . signature = signature self . cardField . cardPayment = payment // after user input is validated cardPayment object from WDECCardField is passed to client if self . cardField . isValid { self . client ?. make ( self . cardField . cardPayment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) } Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @property ( weak , nonatomic ) IBOutlet WDECCardField * cardField ; NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } WDECCardPayment * payment = [ WDECCardPayment new ]; payment . merchantAccountID = merchantAccountID ; payment . requestID = requestID ; payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypePurchase ; payment . signature = signature ; self . cardField . cardPayment = payment ; @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // after user input is validated cardPayment object from WDECCardField is passed to client if ( self . cardField . isValid ) { [ self . client makePayment : self . cardField . cardPayment withCompletion : completionBlock ]; } Note: You can set optional properties after the Card Field is created. Check the API documentation: WDECCardField for more details. Card Token Payment with Card Field \u00b6 Is very rare case when you want to avoid EMV\u00ae 3-D Secure and validate security code for recurring payments but SDK supports it. You can use Card Field to collect just card security code. The payment object is identical to a normal card Field payment (like the example above), but you need to include the card token: Swift 1 2 3 4 5 let cardToken = WDECCardToken () cardToken . tokenID = \"12345678901111\" payment . cardToken = cardToken //set property requireSecurityCode to YES, if you want to collect security code from user payment . requireSecurityCode = YES Objective-C 1 2 3 4 5 WDECCardToken * token = [ WDECCardToken new ]; token . tokenID = @\"12345678901111\" ; payment . cardToken = token ; //set property requireSecurityCode to YES, if you want to collect security code from user payment . requireSecurityCode = YES ; Customizing Simple Card Payments \u00b6 To change colors within the SDK, set properties of the components, that conforms to UIAppearance protocol. Changing any of these will affect every module used in the SDK. 1 - WDECView 2 - WDECCancelButton 3 - WDECSubmitButton 4 - WDECCancelButtonImage 5 - WDECAmountLabel 6 - WDECNavigationBar 7 - WDECTextField 8 - WDECImageView Customizing Animated Card Payments \u00b6 1 - WDECView 2 - WDECCancelButton 3 - WDECSubmitButton 4 - WDECCancelButtonImage 5 - WDECAmountLabel 6 - WDECNavigationBar 7 - WDECTextField 8 - WDECLabel Customizing WDECCardField component \u00b6 You can set additional options for Card Field: card cardBrandHidden cardPayment cursorColor font keyboardAppearance locale placeholderColor textErrorColor textColor numberPlaceholder expirationMonthPlaceholder expirationYearPlaceholder securityCodePlaceholder supportedCardBrands","title":"Card Payments"},{"location":"card-payments/#card-payments","text":"","title":"Card Payments"},{"location":"card-payments/#supported-transaction-types","text":"This payment method supports the following transaction types : WDECTransactionTypeAuthorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. WDECTransactionTypeAuthorizationOnly - verifies the validity of account holder's card, but does not leave an authorized amount. WDECTransactionTypePurchase - charges the account holder's card and immediately transfers the reserved amount. WDECTransactionTypeReferencedAuthorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. References a previous WDECTransactionTypeAuthorization transaction. WDECTransactionTypeReferencedPurchase - charges the account holder's card and immediately transfers the reserved amount. References a previous WDECTransactionTypePurchase transaction. WDECTransactionTypeTokenize - provides a unique token which represents the tokenized card data. This token then can be used in future transactions.","title":"Supported Transaction Types"},{"location":"card-payments/#basic-setup","text":"","title":"Basic Setup"},{"location":"card-payments/#cocoapods","text":"Add to your app's Podfile subspecs: 1 2 3 pod 'paymentSDK/Card' , '~> None' # just by adding CardScanner subspec consumers get option to scan card pod 'paymentSDK/CardScanner' , '~> None'","title":"Cocoapods"},{"location":"card-payments/#camera-permission","text":"To make sure Card Scanner has permission before using camera to scan card, follow the steps in Apple documentation . You need to include NSCameraUsageDescription in your app's Info.plist file.","title":"Camera Permission"},{"location":"card-payments/#basic-card-payment","text":"The most simple card payment flow require This is a code example for a basic card payment: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. let payment = WDECCardPayment () payment . merchantAccountID = merchantAccountID // provided by merchant support payment . requestID = requestID // generated on server; unique for merchantAccountID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . purchase payment . signature = signature // 3. Trigger the payment and handle response in payment completion block. self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to your server for validation or directly provided by your server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored and used for computation in mobile application WDECCardPayment * payment = [ WDECCardPayment new ]; payment . merchantAccountID = merchantAccountID ; // provided by merchant support payment . requestID = requestID ; // generated on your server; unique for merchantAccountID payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypePurchase ; payment . signature = signature ; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ]; Note: You can set optional properties after the payment object is created. Check the API documentation: WDECCardPayment and WDECPayment for more details.","title":"Basic Card Payment"},{"location":"card-payments/#card-token-payment","text":"Token payment in paymentSDK is useful only when you need user interaction. Usually token payment is used in together with EMV\u00ae 3-D Secure. This is a code example for a card payment which uses a card token (obtained from a previous transaction): Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } //first payment let payment = WDECCardPayment () payment . merchantAccountID = merchantAccountID payment . requestID = requestID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . purchase payment . signature = signature self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) func handleReponse ( _ response : WDECPaymentResponse ?) { if let response = response { let cardResponse = response as ? WDECCardPaymentResponse if let cardToken = cardResponse ?. cardToken { //second payment let payment = WDECCardPayment () payment . merchantAccountID = merchantAccountID payment . requestID = requestID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . purchase payment . token = cardToken payment . signature = signature } } } Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } //first payment WDECCardPayment * payment = [ WDECCardPayment new ]; payment . merchantAccountID = merchantAccountID ; payment . requestID = requestID ; payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypePurchase ; payment . signature = signature ; @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } [ self . client makePayment : payment withCompletion : completionBlock ];","title":"Card Token Payment"},{"location":"card-payments/#card-field","text":"Card Field is user interface compontent for collecting sensitive card data (card number, expiration date and security code) which can be added to your UIView as part of your screen/design. Here's example code for a card payment using card field: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @IBOutlet weak var cardField : WDECCardField ! do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } let payment = WDECCardPayment () payment . merchantAccountID = merchantAccountID payment . requestID = requestID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . purchase payment . signature = signature self . cardField . cardPayment = payment // after user input is validated cardPayment object from WDECCardField is passed to client if self . cardField . isValid { self . client ?. make ( self . cardField . cardPayment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) } Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @property ( weak , nonatomic ) IBOutlet WDECCardField * cardField ; NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } WDECCardPayment * payment = [ WDECCardPayment new ]; payment . merchantAccountID = merchantAccountID ; payment . requestID = requestID ; payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypePurchase ; payment . signature = signature ; self . cardField . cardPayment = payment ; @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // after user input is validated cardPayment object from WDECCardField is passed to client if ( self . cardField . isValid ) { [ self . client makePayment : self . cardField . cardPayment withCompletion : completionBlock ]; } Note: You can set optional properties after the Card Field is created. Check the API documentation: WDECCardField for more details.","title":"Card Field"},{"location":"card-payments/#card-token-payment-with-card-field","text":"Is very rare case when you want to avoid EMV\u00ae 3-D Secure and validate security code for recurring payments but SDK supports it. You can use Card Field to collect just card security code. The payment object is identical to a normal card Field payment (like the example above), but you need to include the card token: Swift 1 2 3 4 5 let cardToken = WDECCardToken () cardToken . tokenID = \"12345678901111\" payment . cardToken = cardToken //set property requireSecurityCode to YES, if you want to collect security code from user payment . requireSecurityCode = YES Objective-C 1 2 3 4 5 WDECCardToken * token = [ WDECCardToken new ]; token . tokenID = @\"12345678901111\" ; payment . cardToken = token ; //set property requireSecurityCode to YES, if you want to collect security code from user payment . requireSecurityCode = YES ;","title":"Card Token Payment with Card Field"},{"location":"card-payments/#customizing-simple-card-payments","text":"To change colors within the SDK, set properties of the components, that conforms to UIAppearance protocol. Changing any of these will affect every module used in the SDK. 1 - WDECView 2 - WDECCancelButton 3 - WDECSubmitButton 4 - WDECCancelButtonImage 5 - WDECAmountLabel 6 - WDECNavigationBar 7 - WDECTextField 8 - WDECImageView","title":"Customizing Simple Card Payments"},{"location":"card-payments/#customizing-animated-card-payments","text":"1 - WDECView 2 - WDECCancelButton 3 - WDECSubmitButton 4 - WDECCancelButtonImage 5 - WDECAmountLabel 6 - WDECNavigationBar 7 - WDECTextField 8 - WDECLabel","title":"Customizing Animated Card Payments"},{"location":"card-payments/#customizing-wdeccardfield-component","text":"You can set additional options for Card Field: card cardBrandHidden cardPayment cursorColor font keyboardAppearance locale placeholderColor textErrorColor textColor numberPlaceholder expirationMonthPlaceholder expirationYearPlaceholder securityCodePlaceholder supportedCardBrands","title":"Customizing WDECCardField component"},{"location":"license/","text":"License \u00b6 paymentSDK - MIT License \u00b6 Copyright 2019, Wirecard AG Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 3\u02b3\u1d48 party licenses \u00b6 AFNetworking - MIT License CocoaLumberjack - BSD 3-Clause License GoogleMobileVision - Custom IBAN - BSD 2-Clause License libextobjc - MIT License Lockbox - MIT License Mantle - MIT License MBProgressHUD - MIT License TPKeyboardAvoiding - zlib License ZappMerchantLib - Apache License 2.0","title":"License"},{"location":"license/#license","text":"","title":"License"},{"location":"license/#paymentsdk-mit-license","text":"Copyright 2019, Wirecard AG Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"paymentSDK - MIT License"},{"location":"license/#3rd-party-licenses","text":"AFNetworking - MIT License CocoaLumberjack - BSD 3-Clause License GoogleMobileVision - Custom IBAN - BSD 2-Clause License libextobjc - MIT License Lockbox - MIT License Mantle - MIT License MBProgressHUD - MIT License TPKeyboardAvoiding - zlib License ZappMerchantLib - Apache License 2.0","title":"3\u02b3\u1d48 party licenses"},{"location":"localization/","text":"Localization \u00b6 You can set two types of locale - locale and WDECLocale : locale is sent to backend and used locale is set - selected locale is sent to the backend and the UI is set to specified language, WDECLocale is set - locale is not sent to backend, but UI is set to specified language, Both locale and WDECLocale are set - the locale string is sent to backend and the UI is set according to WDECLocale . Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. let payment = WDECCardPayment () payment . merchantAccountID = merchantAccountID // provided by merchant support payment . requestID = requestID // generated on server; unique for merchantAccountID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . purchase payment . signature = signature payment . locale = WDECLocale . _de let localization = WDECLocalize . appearance () localization . locale = WDECLocale . _ru // 3. Trigger the payment and handle response in payment completion block. self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to your server for validation or directly provided by your server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored and used for computation in mobile application WDECCardPayment * payment = [ WDECCardPayment new ]; payment . merchantAccountID = merchantAccountID ; // provided by merchant support payment . requestID = requestID ; // generated on your server; unique for merchantAccountID payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypePurchase ; payment . signature = signature ; payment . locale = WDECLocale_de ; [[ WDECLocalize appearance ] setLocale : WDECLocale_ru ]; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ]; This example shows the 3rd option (dual setting): the backend locale is set to DE and the frontend WDECLocale to RU. This means that although the backend locale backend is DE, the UI language is RU.","title":"Localization"},{"location":"localization/#localization","text":"You can set two types of locale - locale and WDECLocale : locale is sent to backend and used locale is set - selected locale is sent to the backend and the UI is set to specified language, WDECLocale is set - locale is not sent to backend, but UI is set to specified language, Both locale and WDECLocale are set - the locale string is sent to backend and the UI is set according to WDECLocale . Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. let payment = WDECCardPayment () payment . merchantAccountID = merchantAccountID // provided by merchant support payment . requestID = requestID // generated on server; unique for merchantAccountID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . purchase payment . signature = signature payment . locale = WDECLocale . _de let localization = WDECLocalize . appearance () localization . locale = WDECLocale . _ru // 3. Trigger the payment and handle response in payment completion block. self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to your server for validation or directly provided by your server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored and used for computation in mobile application WDECCardPayment * payment = [ WDECCardPayment new ]; payment . merchantAccountID = merchantAccountID ; // provided by merchant support payment . requestID = requestID ; // generated on your server; unique for merchantAccountID payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypePurchase ; payment . signature = signature ; payment . locale = WDECLocale_de ; [[ WDECLocalize appearance ] setLocale : WDECLocale_ru ]; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ]; This example shows the 3rd option (dual setting): the backend locale is set to DE and the frontend WDECLocale to RU. This means that although the backend locale backend is DE, the UI language is RU.","title":"Localization"},{"location":"major-upgrades/","text":"Major Upgrades \u00b6 Upgrade from 2.x to 3.x \u00b6 In paymentsdk major release 3.x only minimal incompatible changes were provided. paymentSDK was modularized. You need to list all required frameworks (Cocoa subspecs) You need to rename included header files from PaymentSDK to dedicated module umbrella header swift // from PaymentSDK import PaymentSDK // to dedicated module(s) import WDeComApplePay import WDeComCard import WDeComPayPal import WDeComSEPA objective-c // from PaymentSDK #include <PaymentSDK/PaymentSDK.h> // to dedicated module(s) #include <WDeCom/WDeCom.h> // mandatory for all payment methods #include <WDeCom/WDeComApplePay.h> #include <WDeCom/WDeComCard.h> #include <WDeCom/WDeComPayPal.h> #include <WDeCom/WDeComSEPA.h> Classes and Enums name prefix was changed from WD to WDEC to allow integration along other Wirecard proucts. You need to rename used classes and enums in source code.","title":"Major Upgrades"},{"location":"major-upgrades/#major-upgrades","text":"","title":"Major Upgrades"},{"location":"major-upgrades/#upgrade-from-2x-to-3x","text":"In paymentsdk major release 3.x only minimal incompatible changes were provided. paymentSDK was modularized. You need to list all required frameworks (Cocoa subspecs) You need to rename included header files from PaymentSDK to dedicated module umbrella header swift // from PaymentSDK import PaymentSDK // to dedicated module(s) import WDeComApplePay import WDeComCard import WDeComPayPal import WDeComSEPA objective-c // from PaymentSDK #include <PaymentSDK/PaymentSDK.h> // to dedicated module(s) #include <WDeCom/WDeCom.h> // mandatory for all payment methods #include <WDeCom/WDeComApplePay.h> #include <WDeCom/WDeComCard.h> #include <WDeCom/WDeComPayPal.h> #include <WDeCom/WDeComSEPA.h> Classes and Enums name prefix was changed from WD to WDEC to allow integration along other Wirecard proucts. You need to rename used classes and enums in source code.","title":"Upgrade from 2.x to 3.x"},{"location":"paypal/","text":"PayPal \u00b6 Supported Transaction Types \u00b6 This payment method supports the following transaction types : WDECTransactionTypeAuthorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. WDECTransactionTypeAuthorizationOnly - verifies the validity of account holder's card, but does not leave an authorized amount. WDECTransactionTypeDebit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. Basic Setup \u00b6 Cocoapods \u00b6 Add to your app's Podfile subspecs: 1 pod 'paymentSDK/PayPal' , '~> None' Basic PayPal Payment \u00b6 This is a code example for a basic PayPal payment: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. let payment = WDECPayPalPayment () payment . merchantAccountID = merchantAccountID // provided by merchant support payment . requestID = requestID // generated on server; unique for merchantAccountID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . debit let periodic = WDECPeriodic () periodic . periodicType = periodicType periodic . sequenceType = sequenceType payment . periodic = periodic payment . signature = signature // 3. Trigger the payment and handle response in payment completion block. self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; if let error = error { return } self . handleResponse ( response ) }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. WDECPayPalPayment * payment = [ WDECPayPalPayment new ]; payment . merchantAccountID = merchantAccountID ; // provided by merchant support payment . requestID = requestID ; // generated on server; unique for merchantAccountID payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypeDebit ; WDECPeriodic * periodic = [ WDECPeriodic new ]; periodic . periodicType = periodicType ; periodic . sequenceType = sequenceType ; payment . periodic = periodic ; payment . signature = signature ; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ]; Note: You can set optional parameters after the payment object is created. Check the API documentation: WDECPayPalPayment for more details. PayPal payment supports WDECPeriodicTypeRecurring recurring type. Recurring PayPal Payment \u00b6 On a basic level, recurring payments have two phases: The initial request, which must include: periodic type set to WDECPeriodicTypeRecurring , sequence type set to WDECSequenceTypeFirst . The follow-up requests, which must include: periodic type set to WDECPeriodicTypeRecurring , sequence type set to WDECSequenceTypeRecurring , parentTransactionId value from the initial request. So in order to create a recurring payment, you need to: Send a initial request with the appropriate periodic and sequence flags, Save the values of parentTransactionId field generated in this first payment, Reference these values in the follow-up request, then send it with appropriate periodic and sequence flags. Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // first payment let firstPeriodicType = WDECPeriodic () firstPeriodicType . periodicType = . recurring firstPeriodicType . sequenceType = . first let payment = WDECPayPalPayment () payment . merchantAccountID = merchantAccountID payment . requestID = requestID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . debit let periodic = WDECPeriodic () periodic . periodicType = periodicType periodic . sequenceType = sequenceType payment . periodic = firstPeriodicType payment . signature = signature var parentTransactionID : String ? self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; if let error = error { return } self . handleResponse ( response ) }) // handle first result func handleReponse ( _ response : WDECPaymentResponse ?) { guard let response = response else { return } self . parentTransactionID = response . parentTransactionID } // second payment using parentTransactionId let firstPeriodicType = WDECPeriodic () firstPeriodicType . periodicType = . recurring firstPeriodicType . sequenceType = . final let payment = WDECPayPalPayment () payment . merchantAccountID = merchantAccountID payment . requestID = requestID payment . parentTransactionID = self . parentTransactionID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . debit let periodic = WDECPeriodic () periodic . periodicType = periodicType periodic . sequenceType = sequenceType payment . periodic = firstPeriodicType payment . signature = signature self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; if let error = error { return } self . handleResponse ( response ) }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // first payment WDECPeriodic * periodic = [ WDECPeriodic new ]; periodic . periodicType = WDECPeriodicTypeRecurring ; periodic . sequenceType = WDECSequenceTypeFirst ; WDECPayPalPayment * firstPayment = [ WDECPayPalPayment new ]; payment . merchantAccountID = merchantAccountID ; payment . requestID = requestID ; payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypeDebit ; payment . periodic = periodic ; payment . signature = signature ; @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } [ self . client makePayment : payment withCompletion : completionBlock ]; // handle first result - ( void ) handleResponse: ( WDECPaymentResponse * response ) { self . parentTransactionID = response . parentTransactionID ; } // second payment using parentTransactionId WDECPeriodic * periodic = [ WDECPeriodic new ]; periodic . periodicType = WDECPeriodicTypeRecurring ; periodic . sequenceType = WDECSequenceTypeFinal ; WDECPayPalPayment * firstPayment = [ WDECPayPalPayment new ]; payment . merchantAccountID = merchantAccountID ; payment . requestID = requestID ; payment . parentTransactionID = self . parentTransactionID ; payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypeDebit ; payment . periodic = periodic ; payment . signature = signature ; [ self . client makePayment : payment withCompletion : completionBlock ]; Risk referenceID \u00b6 It is used by risk library. The data collected by the Magnes library is used to complement the data that is obtained from the PayPal hosted pages. Swift 1 payment . riskReferenceId = riskReferenceId Objective-C 1 payment . riskReferenceId = riskReferenceId ; Customizing Visuals \u00b6 To change colors within the SDK, set properties of the components, that conforms to UIAppearance protocol. Changing any of these will affect every module used in the SDK. 1 - WDECCancelButtonImage 2 - WDECCancelButton 3 - WDECNavigationBar","title":"PayPal"},{"location":"paypal/#paypal","text":"","title":"PayPal"},{"location":"paypal/#supported-transaction-types","text":"This payment method supports the following transaction types : WDECTransactionTypeAuthorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. WDECTransactionTypeAuthorizationOnly - verifies the validity of account holder's card, but does not leave an authorized amount. WDECTransactionTypeDebit - charges the specified amount from the account holder's bank account and marks it for immediate transfer.","title":"Supported Transaction Types"},{"location":"paypal/#basic-setup","text":"","title":"Basic Setup"},{"location":"paypal/#cocoapods","text":"Add to your app's Podfile subspecs: 1 pod 'paymentSDK/PayPal' , '~> None'","title":"Cocoapods"},{"location":"paypal/#basic-paypal-payment","text":"This is a code example for a basic PayPal payment: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. let payment = WDECPayPalPayment () payment . merchantAccountID = merchantAccountID // provided by merchant support payment . requestID = requestID // generated on server; unique for merchantAccountID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . debit let periodic = WDECPeriodic () periodic . periodicType = periodicType periodic . sequenceType = sequenceType payment . periodic = periodic payment . signature = signature // 3. Trigger the payment and handle response in payment completion block. self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; if let error = error { return } self . handleResponse ( response ) }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. WDECPayPalPayment * payment = [ WDECPayPalPayment new ]; payment . merchantAccountID = merchantAccountID ; // provided by merchant support payment . requestID = requestID ; // generated on server; unique for merchantAccountID payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypeDebit ; WDECPeriodic * periodic = [ WDECPeriodic new ]; periodic . periodicType = periodicType ; periodic . sequenceType = sequenceType ; payment . periodic = periodic ; payment . signature = signature ; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ]; Note: You can set optional parameters after the payment object is created. Check the API documentation: WDECPayPalPayment for more details. PayPal payment supports WDECPeriodicTypeRecurring recurring type.","title":"Basic PayPal Payment"},{"location":"paypal/#recurring-paypal-payment","text":"On a basic level, recurring payments have two phases: The initial request, which must include: periodic type set to WDECPeriodicTypeRecurring , sequence type set to WDECSequenceTypeFirst . The follow-up requests, which must include: periodic type set to WDECPeriodicTypeRecurring , sequence type set to WDECSequenceTypeRecurring , parentTransactionId value from the initial request. So in order to create a recurring payment, you need to: Send a initial request with the appropriate periodic and sequence flags, Save the values of parentTransactionId field generated in this first payment, Reference these values in the follow-up request, then send it with appropriate periodic and sequence flags. Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // first payment let firstPeriodicType = WDECPeriodic () firstPeriodicType . periodicType = . recurring firstPeriodicType . sequenceType = . first let payment = WDECPayPalPayment () payment . merchantAccountID = merchantAccountID payment . requestID = requestID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . debit let periodic = WDECPeriodic () periodic . periodicType = periodicType periodic . sequenceType = sequenceType payment . periodic = firstPeriodicType payment . signature = signature var parentTransactionID : String ? self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; if let error = error { return } self . handleResponse ( response ) }) // handle first result func handleReponse ( _ response : WDECPaymentResponse ?) { guard let response = response else { return } self . parentTransactionID = response . parentTransactionID } // second payment using parentTransactionId let firstPeriodicType = WDECPeriodic () firstPeriodicType . periodicType = . recurring firstPeriodicType . sequenceType = . final let payment = WDECPayPalPayment () payment . merchantAccountID = merchantAccountID payment . requestID = requestID payment . parentTransactionID = self . parentTransactionID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . debit let periodic = WDECPeriodic () periodic . periodicType = periodicType periodic . sequenceType = sequenceType payment . periodic = firstPeriodicType payment . signature = signature self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; if let error = error { return } self . handleResponse ( response ) }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // first payment WDECPeriodic * periodic = [ WDECPeriodic new ]; periodic . periodicType = WDECPeriodicTypeRecurring ; periodic . sequenceType = WDECSequenceTypeFirst ; WDECPayPalPayment * firstPayment = [ WDECPayPalPayment new ]; payment . merchantAccountID = merchantAccountID ; payment . requestID = requestID ; payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypeDebit ; payment . periodic = periodic ; payment . signature = signature ; @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } [ self . client makePayment : payment withCompletion : completionBlock ]; // handle first result - ( void ) handleResponse: ( WDECPaymentResponse * response ) { self . parentTransactionID = response . parentTransactionID ; } // second payment using parentTransactionId WDECPeriodic * periodic = [ WDECPeriodic new ]; periodic . periodicType = WDECPeriodicTypeRecurring ; periodic . sequenceType = WDECSequenceTypeFinal ; WDECPayPalPayment * firstPayment = [ WDECPayPalPayment new ]; payment . merchantAccountID = merchantAccountID ; payment . requestID = requestID ; payment . parentTransactionID = self . parentTransactionID ; payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypeDebit ; payment . periodic = periodic ; payment . signature = signature ; [ self . client makePayment : payment withCompletion : completionBlock ];","title":"Recurring PayPal Payment"},{"location":"paypal/#risk-referenceid","text":"It is used by risk library. The data collected by the Magnes library is used to complement the data that is obtained from the PayPal hosted pages. Swift 1 payment . riskReferenceId = riskReferenceId Objective-C 1 payment . riskReferenceId = riskReferenceId ;","title":"Risk referenceID"},{"location":"paypal/#customizing-visuals","text":"To change colors within the SDK, set properties of the components, that conforms to UIAppearance protocol. Changing any of these will affect every module used in the SDK. 1 - WDECCancelButtonImage 2 - WDECCancelButton 3 - WDECNavigationBar","title":"Customizing Visuals"},{"location":"release-notes/","text":"","title":"Release Notes"},{"location":"sepa/","text":"SEPA \u00b6 Supported Transaction Types \u00b6 This payment method supports the following transaction types : WDECTransactionTypeDebit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. WDECTransactionTypeAuthorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. WDECTransactionTypePendingDebit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. The pending status indicates that additional processing/approval is required before the transaction is cleared. Basic Setup \u00b6 Cocoapods \u00b6 Add to your app's Podfile subspecs: 1 2 3 pod 'paymentSDK/SEPA' , '~> None' # just by adding IBANScanner subspec consumers get option to scan IBAN pod 'paymentSDK/IBANScanner' , '~> None' To make sure IBAN Scanner has permission before using camera to scan IBAN, follow the steps in Apple documentation . You need to include NSCameraUsageDescription in your app's Info.plist file. Simple SEPA Payment \u00b6 This is a code example for a basic SEPA payment: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. let payment = WDECSEPAPayment () payment . merchantAccountID = merchantAccountID // provided by merchant support payment . requestID = requestID // generated on server; unique for merchantAccountID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . debit payment . creditorID = creditorID payment . mandateID = mandateID payment . signature = signature // 3. Trigger the payment and handle response in payment completion block. self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. WDECSEPAPayment * payment = [ WDECSEPAPayment new ]; payment . merchantAccountID = merchantAccountID ; // provided by merchant support payment . requestID = requestID ; // generated on server; unique for merchantAccountID payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypeDebit ; payment . creditorID = creditorID payment . mandateID = mandateID payment . signature = signature ; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ]; Customizing SEPA Payments \u00b6 To change colors within the SDK, set properties of the components, that conforms to UIAppearance protocol. Changing any of these will affect every module used in the SDK. 1 - WDECView 2 - WDECCancelButton 3 - WDECSubmitButton 4 - WDECCancelButtonImage 5 - WDECAmountLabel 6 - WDECNavigationBar 7 - WDECTextView 8 - WDECImageView 9 - WDECTextField 10 - WDECSwitch","title":"SEPA Direct Debit"},{"location":"sepa/#sepa","text":"","title":"SEPA"},{"location":"sepa/#supported-transaction-types","text":"This payment method supports the following transaction types : WDECTransactionTypeDebit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. WDECTransactionTypeAuthorization - places the account holder's funds on hold, pending future capture, re-authorization or void transaction. WDECTransactionTypePendingDebit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. The pending status indicates that additional processing/approval is required before the transaction is cleared.","title":"Supported Transaction Types"},{"location":"sepa/#basic-setup","text":"","title":"Basic Setup"},{"location":"sepa/#cocoapods","text":"Add to your app's Podfile subspecs: 1 2 3 pod 'paymentSDK/SEPA' , '~> None' # just by adding IBANScanner subspec consumers get option to scan IBAN pod 'paymentSDK/IBANScanner' , '~> None' To make sure IBAN Scanner has permission before using camera to scan IBAN, follow the steps in Apple documentation . You need to include NSCameraUsageDescription in your app's Info.plist file.","title":"Cocoapods"},{"location":"sepa/#simple-sepa-payment","text":"This is a code example for a basic SEPA payment: Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. let payment = WDECSEPAPayment () payment . merchantAccountID = merchantAccountID // provided by merchant support payment . requestID = requestID // generated on server; unique for merchantAccountID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"EUR\" payment . transactionType = . debit payment . creditorID = creditorID payment . mandateID = mandateID payment . signature = signature // 3. Trigger the payment and handle response in payment completion block. self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. WDECSEPAPayment * payment = [ WDECSEPAPayment new ]; payment . merchantAccountID = merchantAccountID ; // provided by merchant support payment . requestID = requestID ; // generated on server; unique for merchantAccountID payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"EUR\" ; payment . transactionType = WDECTransactionTypeDebit ; payment . creditorID = creditorID payment . mandateID = mandateID payment . signature = signature ; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ];","title":"Simple SEPA Payment"},{"location":"sepa/#customizing-sepa-payments","text":"To change colors within the SDK, set properties of the components, that conforms to UIAppearance protocol. Changing any of these will affect every module used in the SDK. 1 - WDECView 2 - WDECCancelButton 3 - WDECSubmitButton 4 - WDECCancelButtonImage 5 - WDECAmountLabel 6 - WDECNavigationBar 7 - WDECTextView 8 - WDECImageView 9 - WDECTextField 10 - WDECSwitch","title":"Customizing SEPA Payments"},{"location":"theming/","text":"User Interface Customization \u00b6 For changing colors within the paymentSDK simply set particular components by UIAppearance protocol. Components \u00b6 Changing these components would afect all modules used within SDK. List of all customizable components is in the public header file of core SDK module <WDeCom/WDeCom.h> . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 WDECAmountLabel WDECButton WDECLabel WDECSubmitButton WDECCancelButton WDECCancelButtonImage WDECImageView WDECNavigationBar WDECLocalize WDECSwitch WDECTextView WDECTextfield WDECCardTextField WDECView WDECCardFieldScannerGallery WDECAnimatedCardFieldScannerGallery Some of these components contains UI_APPEARANCE_SELECTOR properties, that can be set on top of the UIKit capabilities. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [[ WDECCancelButtonImage appearance ] setImageColor : color ]; [[ WDECImageView appearance ] setImageColor : color ]; [[ WDECLocalize appearance ] setLocale : locale ]; [[ WDECNavigationBar appearance ] setBarStyle : barStyle ]; [[ WDECTextfield appearance ] setPlaceholderColor : color ]; [[ WDECTextfield appearance ] setIconsStyle : iconsStyle ]; [[ WDECTextfield appearance ] setUnderlineColor : underlineColor ]; [[ WDECTextfield appearance ] setUnderlineEditingColor : underlineEditingColor ]; [[ WDECTextfield appearance ] setErrorColor : errorColor ]; [[ WDECCardFieldScannerGallery appearance ] setScanImage : image ]; [[ WDECCardFieldScannerGallery appearance ] setScanImageTintColor : color ]; [[ WDECCardFieldScannerGallery appearance ] setEnableScanImageButton : enable ]; [[ WDECCardFieldScannerGallery appearance ] setScanToolbarButtonTitle : title ]; [[ WDECCardFieldScannerGallery appearance ] setEnableScanToolbarButton : enable ]; [[ WDECAnimatedCardFieldScannerGallery appearance ] setScanToolbarButtonTitle : title ]; [[ WDECAnimatedCardFieldScannerGallery appearance ] setEnableScanToolbarButton : enable ]; Changing Font \u00b6 This can be changed only for WDECCardfield component.","title":"User Interface"},{"location":"theming/#user-interface-customization","text":"For changing colors within the paymentSDK simply set particular components by UIAppearance protocol.","title":"User Interface Customization"},{"location":"theming/#components","text":"Changing these components would afect all modules used within SDK. List of all customizable components is in the public header file of core SDK module <WDeCom/WDeCom.h> . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 WDECAmountLabel WDECButton WDECLabel WDECSubmitButton WDECCancelButton WDECCancelButtonImage WDECImageView WDECNavigationBar WDECLocalize WDECSwitch WDECTextView WDECTextfield WDECCardTextField WDECView WDECCardFieldScannerGallery WDECAnimatedCardFieldScannerGallery Some of these components contains UI_APPEARANCE_SELECTOR properties, that can be set on top of the UIKit capabilities. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [[ WDECCancelButtonImage appearance ] setImageColor : color ]; [[ WDECImageView appearance ] setImageColor : color ]; [[ WDECLocalize appearance ] setLocale : locale ]; [[ WDECNavigationBar appearance ] setBarStyle : barStyle ]; [[ WDECTextfield appearance ] setPlaceholderColor : color ]; [[ WDECTextfield appearance ] setIconsStyle : iconsStyle ]; [[ WDECTextfield appearance ] setUnderlineColor : underlineColor ]; [[ WDECTextfield appearance ] setUnderlineEditingColor : underlineEditingColor ]; [[ WDECTextfield appearance ] setErrorColor : errorColor ]; [[ WDECCardFieldScannerGallery appearance ] setScanImage : image ]; [[ WDECCardFieldScannerGallery appearance ] setScanImageTintColor : color ]; [[ WDECCardFieldScannerGallery appearance ] setEnableScanImageButton : enable ]; [[ WDECCardFieldScannerGallery appearance ] setScanToolbarButtonTitle : title ]; [[ WDECCardFieldScannerGallery appearance ] setEnableScanToolbarButton : enable ]; [[ WDECAnimatedCardFieldScannerGallery appearance ] setScanToolbarButtonTitle : title ]; [[ WDECAnimatedCardFieldScannerGallery appearance ] setEnableScanToolbarButton : enable ];","title":"Components"},{"location":"theming/#changing-font","text":"This can be changed only for WDECCardfield component.","title":"Changing Font"},{"location":"zapp/","text":"Zapp \u00b6 With Zapp, there are two payments flow. Whether the customer has a banking application installed on their phone decides which one is used : Banking application is installed - this app is opened after a successful response from Wirecard payment gateway. No banking application - SDK prompts a pop-up informing the user to provide BRN (see explanation below) to a banking application on another device and awaits confirmation. BRN is short for Basket Reference Number, a unique temporary code provided by Zapp (and conveyed to the customer by the merchant) which identifies the order which is being paid. Supported Transaction Types \u00b6 WDECTransactionTypeDebit - charges the specified amount from the account holder's bank account and marks it for immediate transfer. Zapp transaction and delivery types \u00b6 Transaction types: BILLPT - Bill payment PAYMT - Retail item payment INVOICE - Invoice payment DONATIONS - Donation payment Delivery types: COLLST - Store collection. The consumer chose to collect the goods from the store personally. DELTAD - Delivery to address. The Consumer chose to have the goods delivered to the specified address. DIGDEL - Digital delivery. The Consumer chose to receive items electronically. SERVICE - Service provided. For SMB transactions where there is no need for a delivery address F2F - Face-to-face transactions. Primarily for use with an SMB transaction. NONE - No delivery Basic Setup \u00b6 Cocoapods \u00b6 Add to your app's Podfile subspecs: 1 pod 'paymentSDK/ZAPP, ' ~> None ' Simple Zapp Payment \u00b6 Zapp requires additional setup of the appScheme field in payment object and CFBundleURLSchemes and LSApplicationQueriesSchemes keys in Info.plist of the app. Info.plist: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <key> CFBundleURLTypes </key> <array> <dict> <key> CFBundleURLName </key> <string> your.app.bundleID </string> <key> CFBundleURLSchemes </key> <array> <string> yourAppScheme </string> </array> </dict> </array> <key> LSApplicationQueriesSchemes </key> <array> <string> zapp </string> </array> SDK handles redirect from payment provider app or web page. Method openURL should be called in AppDelegate delegate method. Objective-C 1 2 3 4 5 6 - ( BOOL ) application: ( UIApplication * ) app openURL: ( NSURL * ) url options: ( NSDictionary < UIApplicationOpenURLOptionsKey , id > * ) options { BOOL openURL = [ self . client openURL : url ]; return openURL ; } Swift 1 2 3 4 func application ( _ app : UIApplication , open url : URL , options : [ UIApplication . OpenURLOptionsKey : Any ] = [:]) -> Bool { let openURL = self . client ?. open ( url ) ?? false return openURL } Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. let payment = WDECPBBAPayment () payment . merchantAccountID = merchantAccountID // provided by merchant support payment . requestID = requestID // generated on server; unique for merchantAccountID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"GBP\" payment . transactionType = . debit payment . pbbaTransactionType = \"PAYMNT\" payment . pbbaDeliveryType = \"SERVICE\" payment . appScheme = yourAppScheme payment . signature = signature // 3. Trigger the payment and handle response in payment completion block. self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. WDECPBBAPayment * payment = [ WDECPBBAPayment new ]; payment . merchantAccountID = merchantAccountID ; // provided by merchant support payment . requestID = requestID ; // generated on server; unique for merchantAccountID payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"GBP\" ; payment . transactionType = WDECTransactionTypeDebit ; payment . pbbaTransactionType = @\"PAYMNT\" ; payment . pbbaDeliveryType = @\"SERVICE\" ; payment . appScheme = yourAppScheme ; payment . signature = signature ; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ];","title":"Zapp"},{"location":"zapp/#zapp","text":"With Zapp, there are two payments flow. Whether the customer has a banking application installed on their phone decides which one is used : Banking application is installed - this app is opened after a successful response from Wirecard payment gateway. No banking application - SDK prompts a pop-up informing the user to provide BRN (see explanation below) to a banking application on another device and awaits confirmation. BRN is short for Basket Reference Number, a unique temporary code provided by Zapp (and conveyed to the customer by the merchant) which identifies the order which is being paid.","title":"Zapp"},{"location":"zapp/#supported-transaction-types","text":"WDECTransactionTypeDebit - charges the specified amount from the account holder's bank account and marks it for immediate transfer.","title":"Supported Transaction Types"},{"location":"zapp/#zapp-transaction-and-delivery-types","text":"Transaction types: BILLPT - Bill payment PAYMT - Retail item payment INVOICE - Invoice payment DONATIONS - Donation payment Delivery types: COLLST - Store collection. The consumer chose to collect the goods from the store personally. DELTAD - Delivery to address. The Consumer chose to have the goods delivered to the specified address. DIGDEL - Digital delivery. The Consumer chose to receive items electronically. SERVICE - Service provided. For SMB transactions where there is no need for a delivery address F2F - Face-to-face transactions. Primarily for use with an SMB transaction. NONE - No delivery","title":"Zapp transaction and delivery types"},{"location":"zapp/#basic-setup","text":"","title":"Basic Setup"},{"location":"zapp/#cocoapods","text":"Add to your app's Podfile subspecs: 1 pod 'paymentSDK/ZAPP, ' ~> None '","title":"Cocoapods"},{"location":"zapp/#simple-zapp-payment","text":"Zapp requires additional setup of the appScheme field in payment object and CFBundleURLSchemes and LSApplicationQueriesSchemes keys in Info.plist of the app. Info.plist: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <key> CFBundleURLTypes </key> <array> <dict> <key> CFBundleURLName </key> <string> your.app.bundleID </string> <key> CFBundleURLSchemes </key> <array> <string> yourAppScheme </string> </array> </dict> </array> <key> LSApplicationQueriesSchemes </key> <array> <string> zapp </string> </array> SDK handles redirect from payment provider app or web page. Method openURL should be called in AppDelegate delegate method. Objective-C 1 2 3 4 5 6 - ( BOOL ) application: ( UIApplication * ) app openURL: ( NSURL * ) url options: ( NSDictionary < UIApplicationOpenURLOptionsKey , id > * ) options { BOOL openURL = [ self . client openURL : url ]; return openURL ; } Swift 1 2 3 4 func application ( _ app : UIApplication , open url : URL , options : [ UIApplication . OpenURLOptionsKey : Any ] = [:]) -> Bool { let openURL = self . client ?. open ( url ) ?? false return openURL } Swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. do { try self . client = WDECClient . init ( hostname : hostname ) } catch { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. let payment = WDECPBBAPayment () payment . merchantAccountID = merchantAccountID // provided by merchant support payment . requestID = requestID // generated on server; unique for merchantAccountID payment . amount = NSDecimalNumber ( mantissa : 199 , exponent : - 2 , isNegative : NO ) payment . currency = \"GBP\" payment . transactionType = . debit payment . pbbaTransactionType = \"PAYMNT\" payment . pbbaDeliveryType = \"SERVICE\" payment . appScheme = yourAppScheme payment . signature = signature // 3. Trigger the payment and handle response in payment completion block. self . client ?. make ( payment , withCompletion :{( response : WDECPaymentResponse ?, error : Error ?) in // for each failure error object is provided; guard let error = error else { return } if let response = response { self . handleResponse ( response ) } }) Objective-C 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 1. Initialize client object // Parameters (hostname, merchantAccountID) may come from server to make it configurable. NSError * error = nil ; self . client = [[ WDECClient alloc ] initWithHostname : hostname error : & error ]; if ( error ) { // the device is checked during initialization for jailbreak. // It is risky to make payments on jailbroken devices. return ; } // 2. Initialize payment object and set mandatory properties // Parameters (amount, currency, transactionType) shall be sent to server for validation or just provided by server // and used to generate signature. Signature MUST be generated on server side. // Signature doc: https://document-center.wirecard.com/display/PTD/Signature+v2 // Secret Key shall never be stored in application. WDECPBBAPayment * payment = [ WDECPBBAPayment new ]; payment . merchantAccountID = merchantAccountID ; // provided by merchant support payment . requestID = requestID ; // generated on server; unique for merchantAccountID payment . amount = [ NSDecimalNumber decimalNumberWithMantissa : 199 exponent : - 2 isNegative : NO ]; payment . currency = @\"GBP\" ; payment . transactionType = WDECTransactionTypeDebit ; payment . pbbaTransactionType = @\"PAYMNT\" ; payment . pbbaDeliveryType = @\"SERVICE\" ; payment . appScheme = yourAppScheme ; payment . signature = signature ; // 3. Create payment completion block to handle response @ weakify ( self ); WDECCompletionBlock completionBlock = ^ ( WDECPaymentResponse * _Nullable response , NSError * _Nullable error ) { @ strongify ( self ); // for each failure error object is provided; if ( error ) { return ; } [ self handleResponse : response ]; } // 4. Trigger the payment [ self . client makePayment : payment withCompletion : completionBlock ];","title":"Simple Zapp Payment"}]}